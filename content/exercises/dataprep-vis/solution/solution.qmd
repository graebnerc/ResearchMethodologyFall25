---
title: "Recap exercises: import, preparation and visualization"
subtitle: "A possible solution"
date: "2025-11-07"

# options specified here will apply to all posts in this folder

# true to enable banner style title blocks (but need to work on this)
title-block-banner: false

# freeze prevents posts from re-rendering unless explicitly told to do so 
#  (for more, see https://quarto.org/docs/projects/code-execution.html#freeze)
# true: never re-render during project render
# auto: re-render only when source changes
execute: 
  freeze: auto
  message: false
  warning: false
  error: true

format: 
  html:
    theme:
      light: 
        - journal
        - ../../../../css/custom.scss # Change the default colour
    highlight: tango
    toc: true
    toc_depth: 2
    toc-location: right
    number_sections: true
    code-fold: false
---

## Exercise 1: Customer Satisfaction Tracking

For this exercise we need the following packages:

```{r}
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(kableExtra) # <- only for the presentation on the webpage
```

Since the csv file is in good shape we can just read it via `data.table::fread()`
or, because it is already very clean, with `readr::read_csv()`:

```{r}
# Note: adjust to you project and best use here::here()
customers_data <- read_csv(
  file = "customer_satisfaction.csv")
```

This is how the current data looks like:

```{r}
head(customers_data) |>
  kable()
```

To transform it into the desired long format we use `tidyr::pivot_longer()`.
Here we can make our live easier by using the selection helper `dplyr::starts_with()`
to capture all columns starting with `q`.
But a simple application only brings us that far:

```{r}
customers_data |>
  pivot_longer(
    cols = all_of(starts_with("q"))
    ) |>
  head() |>
  kable()
```

The column `name` still contains information about both the quarter and the metric.
There are a number of ways we can separate this column.

One way would be to use the argument `names_sep` of `pivot_longer()` and then
give two column names to `names_to`. This works in our case but note that it
gives a warning that some parts of the column are dropped:

```{r}
#| warning: true
customers_long <- customers_data |>
  pivot_longer(
    cols = starts_with("q"), 
    names_sep = "_", 
    names_to = c("quarter", "metric")
    ) 
head(customers_long)
```

This is because we
are telling the function to separate the column using the token `_`, but this
token appears more than once (but we only provide two column names). In our case
this is save to ignore, but when you want to avoid it, you can use the function
`dplyr::separate_wider_delim()`, which allows for more sophisticate separation procedures.
In our case, we can set `too_many = "merge"`, which tells the function to only 
split on the first underscore and merge everything else together:

```{r}
customers_long <- customers_data |>
  pivot_longer(
    cols = starts_with("q"),
    names_to = "full_name",
    values_to = "rating"
  ) |>
  separate_wider_delim(
    cols = full_name, 
    delim = "_",
    names = c("quarter", "metric"), 
    too_many = "merge")

head(customers_long) |>
  kable()
```

Next we need to compute average ratings for each combination of quarter and 
metric type:

```{r}
satisfaction_summary <- customers_long |>
  group_by(quarter, metric) |>
  summarise(avg_rating = mean(rating), .groups = "drop") 

kable(satisfaction_summary)
```


> Note: there are different ways of doing this. Instead of the more explicit
`group_by()` you could have used `summarize(..., .by=c())`.

The final step is then to create the visualization using `ggplot2`.
The only thing to note is that we need to be explicit regarding the grouping
and set 

```{r}
ggplot(
  data = satisfaction_summary, 
  mapping = aes(
    x = quarter, 
    y = avg_rating, 
    colour = metric, 
    group = metric)
  ) +
  geom_point() +
  geom_line() +
  theme_light()
```


::: {.callout-tip collapse="true"}
#### Why do we need `group = metric`?

When you use `geom_line()`, `ggplot2` needs to know which points to connect. 
By default, `ggplot2` automatically creates groups based on the combination of 
all discrete variables in your data.
In our case these are the two variables `quarter` and `metric`.

So `ggplot2` creates groups based on the combination of both these variables:

1. `q1 + product_value` (1 point)
2. `q1 + service_quality` (1 point)
3. `q2 + product_value` (1 point)
4. `q2 + service_quality` (1 point)
5. `q3 + product_value` (1 point)
6. `q3 + service_quality` (1 point)

Each group has only one observation, so there's nothing to connect with a line!

What we *actually* want is to have separate lines for each metric, i.e.
one line for `product_value` across all quarters and 
one line for `service_quality` across all quarters. 

So you need to tell `ggplot2`: 
"Group by metric only, not by the combination of all discrete variables, 
which would be quarter and metric!"

:::


Of course, there are many ways to make the plot pretties, but here we may leave
it at this!

To also complete the bonus challenge, we need to compute the improvement after
the intervention, i.e. from `q1` to the other two quarters. We will do this by
computer the average for `q2` and `q3`, compute the relative change to `q1` and
then rank the data according to their relative changes.

Here are all steps conducted separately: first, create a new variable to
group periods before and after the intervention:

```{r}
step1 <- satisfaction_summary |>
  mutate(
    intervention = ifelse(test = quarter=="q1", yes = "No", no = "Yes")
    )
kable(step1)
```


Now compute the respective averages:

```{r}
step2 <- step1 |>
  summarise(
    avg_rating = mean(avg_rating), .by = c("intervention", "metric")
    )
kable(step2)
```

Make it wider:

```{r}
step3 <- step2 |>
  pivot_wider(names_from = intervention, values_from = avg_rating) 
kable(step3)
```

And now compute the relative change:

```{r}
step4 <- step3 |>
  mutate(
    absolute_change = Yes - No,
    relative_change = (absolute_change / No)*100
    ) |>
  select(-No, -Yes)
kable(step4)
```

Or, all in one call:

```{r}
satisfaction_summary |>
  mutate(
    intervention = ifelse(test = quarter=="q1", yes = "No", no = "Yes")
    ) |>
  summarise(
    avg_rating = mean(avg_rating), .by = c("intervention", "metric")
  ) |>
  pivot_wider(names_from = intervention, values_from = avg_rating) |>
  mutate(
    absolute_change = Yes - No,
    relative_change = (absolute_change / No)*100
    ) |>
  select(-No, -Yes) |> 
  kable()
```

## Exercise 2: Pricing Strategy Analysis

For this exercise we need the following packages:

```{r}
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(kableExtra) # <- only for the presentation on the webpage
```

Since the csv file is in good shape we can just read it via `data.table::fread()`
or, because it is already very clean, with `readr::read_csv()`:

```{r}
# Note: adjust to you project and best use here::here()
pricing_data <- read_csv(
  file = "pricing_experiment.csv")
```

This is how the current data looks like:

```{r}
head(pricing_data) |>
  kable()
```

To compute mean conversion rates and transaction values across trials for 
each product and pricing strategy, we group the data for products and pricing
strategies:

```{r}
product_averages <- pricing_data |>
  group_by(product_id, pricing_strategy) |>
  summarise(
    conversion_rate = mean(conversion_rate), 
    transaction_value = mean(avg_transaction_value), 
    .groups = "drop"
    )

head(product_averages) |>
  kable()
```

The next task asks us to transform the data so that each row is one product and
the pricing strategies become separate columns for both 
`conversion_rate` and `avg_transaction_value`, but with column names 
combining the information on the metric and pricing strategy.

That means we need to make the data wider, and use the argument `names_sep`
to introduce a separator into the new column names:

```{r}
product_wide <- product_averages |>
  pivot_wider(
    id_cols = product_id,
    names_from = pricing_strategy,
    values_from = c(conversion_rate, transaction_value),
    names_sep = "_"
  )

head(product_wide) |>
  kable()
```


We now need to compute expected revenue per customer by multiplying
conversion rates and average transaction values for each pricing strategy:

```{r}
expected_revs <- product_wide |>
  mutate(
    standard_revenue = conversion_rate_standard * transaction_value_standard,
    discount_10_revenue = conversion_rate_discount_10 * transaction_value_discount_10,
    premium_revenue = conversion_rate_premium * transaction_value_premium
  )

head(expected_revs) |>
  kable()
```

This tells you the expected revenue from each pricing approach.

Finally, we want a scatter plot that compares the pricing strategies for
each product, illustrating whether the same pricing strategy is the best
for each product. To this end we create the scatter plot with expected
revenues for standard and discount pricing on the x and y axis, and add a
diagonal reference line. If all points are above (below) the reference line,
discount (standard) pricing is always better:

```{r}
ggplot(
  data = expected_revs, 
  mapping = aes(
    x = standard_revenue, 
    y = discount_10_revenue)
  ) +
  geom_abline(
    intercept = 0, slope = 1, linetype = "dashed", 
    color = "gray50", linewidth = 1
    ) +
  geom_point(size = 3, alpha = 0.6, color = "#0072B2") +
  labs(
    title = "Comparing Expected Revenue: \nStandard vs. Discount Pricing",
    subtitle = "Each point represents one product",
    x = "Expected Revenue - Standard Pricing",
    y = "Expected Revenue - 10% Discount Pricing",
    caption = "Dashed line shows equal performance."
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 11, color = "gray30")
  ) +
  coord_fixed(ratio = 1)  # Makes comparison easier
```
