{
  "hash": "4fc5b982131e29cc3b4f9635a8254c20",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Recap exercises: import, preparation and visualization\"\nsubtitle: \"A possible solution\"\ndate: \"2025-11-07\"\n\nformat:\n  html:\n    code-fold: false\n---\n\n## Exercise 1: Customer Satisfaction Tracking\n\nFor this exercise we need the following packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(kableExtra) # <- only for the presentation on the webpage\n```\n:::\n\n\nSince the csv file is in good shape we can just read it via `data.table::fread()`\nor, because it is already very clean, with `readr::read_csv()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Note: adjust to you project and best use here::here()\ncustomers_data <- read_csv(\n  file = \"customer_satisfaction.csv\")\n```\n:::\n\n\nThis is how the current data looks like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(customers_data) |>\n  kable()\n```\n\n::: {.cell-output-display}\n\n\n| customer_id| account_age_months| q1_service_quality| q1_product_value| q2_service_quality| q2_product_value| q3_service_quality| q3_product_value|\n|-----------:|------------------:|------------------:|----------------:|------------------:|----------------:|------------------:|----------------:|\n|           1|                 12|                  3|                5|                  4|                2|                  5|                3|\n|           2|                 25|                  4|                1|                  4|                4|                  5|                3|\n|           3|                 34|                  4|                5|                  2|                3|                  5|                5|\n|           4|                 20|                  1|                5|                  5|                5|                  3|                5|\n|           5|                 16|                  3|                1|                  2|                5|                  5|                5|\n|           6|                 13|                  5|                1|                  5|                4|                  4|                4|\n\n\n:::\n:::\n\n\nTo transform it into the desired long format we use `tidyr::pivot_longer()`.\nHere we can make our live easier by using the selection helper `dplyr::starts_with()`\nto capture all columns starting with `q`.\nBut a simple application only brings us that far:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncustomers_data |>\n  pivot_longer(\n    cols = all_of(starts_with(\"q\"))\n    ) |>\n  head() |>\n  kable()\n```\n\n::: {.cell-output-display}\n\n\n| customer_id| account_age_months|name               | value|\n|-----------:|------------------:|:------------------|-----:|\n|           1|                 12|q1_service_quality |     3|\n|           1|                 12|q1_product_value   |     5|\n|           1|                 12|q2_service_quality |     4|\n|           1|                 12|q2_product_value   |     2|\n|           1|                 12|q3_service_quality |     5|\n|           1|                 12|q3_product_value   |     3|\n\n\n:::\n:::\n\n\nThe column `name` still contains information about both the quarter and the metric.\nThere are a number of ways we can separate this column.\n\nOne way would be to use the argument `names_sep` of `pivot_longer()` and then\ngive two column names to `names_to`. This works in our case but note that it\ngives a warning that some parts of the column are dropped:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncustomers_long <- customers_data |>\n  pivot_longer(\n    cols = starts_with(\"q\"), \n    names_sep = \"_\", \n    names_to = c(\"quarter\", \"metric\")\n    ) \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Expected 2 pieces. Additional pieces discarded in 6 rows [1, 2, 3, 4,\n5, 6].\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(customers_long)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 Ã— 5\n  customer_id account_age_months quarter metric  value\n        <dbl>              <dbl> <chr>   <chr>   <dbl>\n1           1                 12 q1      service     3\n2           1                 12 q1      product     5\n3           1                 12 q2      service     4\n4           1                 12 q2      product     2\n5           1                 12 q3      service     5\n6           1                 12 q3      product     3\n```\n\n\n:::\n:::\n\n\nThis is because we\nare telling the function to separate the column using the token `_`, but this\ntoken appears more than once (but we only provide two column names). In our case\nthis is save to ignore, but when you want to avoid it, you can use the function\n`dplyr::separate_wider_delim()`, which allows for more sophisticate separation procedures.\nIn our case, we can set `too_many = \"merge\"`, which tells the function to only \nsplit on the first underscore and merge everything else together:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncustomers_long <- customers_data |>\n  pivot_longer(\n    cols = starts_with(\"q\"),\n    names_to = \"full_name\",\n    values_to = \"rating\"\n  ) |>\n  separate_wider_delim(\n    cols = full_name, \n    delim = \"_\",\n    names = c(\"quarter\", \"metric\"), \n    too_many = \"merge\")\n\nhead(customers_long) |>\n  kable()\n```\n\n::: {.cell-output-display}\n\n\n| customer_id| account_age_months|quarter |metric          | rating|\n|-----------:|------------------:|:-------|:---------------|------:|\n|           1|                 12|q1      |service_quality |      3|\n|           1|                 12|q1      |product_value   |      5|\n|           1|                 12|q2      |service_quality |      4|\n|           1|                 12|q2      |product_value   |      2|\n|           1|                 12|q3      |service_quality |      5|\n|           1|                 12|q3      |product_value   |      3|\n\n\n:::\n:::\n\n\nNext we need to compute average ratings for each combination of quarter and \nmetric type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsatisfaction_summary <- customers_long |>\n  group_by(quarter, metric) |>\n  summarise(avg_rating = mean(rating), .groups = \"drop\") \n\nkable(satisfaction_summary)\n```\n\n::: {.cell-output-display}\n\n\n|quarter |metric          | avg_rating|\n|:-------|:---------------|----------:|\n|q1      |product_value   |       2.90|\n|q1      |service_quality |       3.10|\n|q2      |product_value   |       3.52|\n|q2      |service_quality |       3.44|\n|q3      |product_value   |       3.98|\n|q3      |service_quality |       4.14|\n\n\n:::\n:::\n\n\n\n> Note: there are different ways of doing this. Instead of the more explicit\n`group_by()` you could have used `summarize(..., .by=c())`.\n\nThe final step is then to create the visualization using `ggplot2`.\nThe only thing to note is that we need to be explicit regarding the grouping\nand set \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data = satisfaction_summary, \n  mapping = aes(\n    x = quarter, \n    y = avg_rating, \n    colour = metric, \n    group = metric)\n  ) +\n  geom_point() +\n  geom_line() +\n  theme_light()\n```\n\n::: {.cell-output-display}\n![](solution_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n::: {.callout-tip collapse=\"true\"}\n#### Why do we need `group = metric`?\n\nWhen you use `geom_line()`, `ggplot2` needs to know which points to connect. \nBy default, `ggplot2` automatically creates groups based on the combination of \nall discrete variables in your data.\nIn our case these are the two variables `quarter` and `metric`.\n\nSo `ggplot2` creates groups based on the combination of both these variables:\n\n1. `q1 + product_value` (1 point)\n2. `q1 + service_quality` (1 point)\n3. `q2 + product_value` (1 point)\n4. `q2 + service_quality` (1 point)\n5. `q3 + product_value` (1 point)\n6. `q3 + service_quality` (1 point)\n\nEach group has only one observation, so there's nothing to connect with a line!\n\nWhat we *actually* want is to have separate lines for each metric, i.e.\none line for `product_value` across all quarters and \none line for `service_quality` across all quarters. \n\nSo you need to tell `ggplot2`: \n\"Group by metric only, not by the combination of all discrete variables, \nwhich would be quarter and metric!\"\n\n:::\n\n\nOf course, there are many ways to make the plot pretties, but here we may leave\nit at this!\n\nTo also complete the bonus challenge, we need to compute the improvement after\nthe intervention, i.e. from `q1` to the other two quarters. We will do this by\ncomputer the average for `q2` and `q3`, compute the relative change to `q1` and\nthen rank the data according to their relative changes.\n\nHere are all steps conducted separately: first, create a new variable to\ngroup periods before and after the intervention:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstep1 <- satisfaction_summary |>\n  mutate(\n    intervention = ifelse(test = quarter==\"q1\", yes = \"No\", no = \"Yes\")\n    )\nkable(step1)\n```\n\n::: {.cell-output-display}\n\n\n|quarter |metric          | avg_rating|intervention |\n|:-------|:---------------|----------:|:------------|\n|q1      |product_value   |       2.90|No           |\n|q1      |service_quality |       3.10|No           |\n|q2      |product_value   |       3.52|Yes          |\n|q2      |service_quality |       3.44|Yes          |\n|q3      |product_value   |       3.98|Yes          |\n|q3      |service_quality |       4.14|Yes          |\n\n\n:::\n:::\n\n\n\nNow compute the respective averages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstep2 <- step1 |>\n  summarise(\n    avg_rating = mean(avg_rating), .by = c(\"intervention\", \"metric\")\n    )\nkable(step2)\n```\n\n::: {.cell-output-display}\n\n\n|intervention |metric          | avg_rating|\n|:------------|:---------------|----------:|\n|No           |product_value   |       2.90|\n|No           |service_quality |       3.10|\n|Yes          |product_value   |       3.75|\n|Yes          |service_quality |       3.79|\n\n\n:::\n:::\n\n\nMake it wider:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstep3 <- step2 |>\n  pivot_wider(names_from = intervention, values_from = avg_rating) \nkable(step3)\n```\n\n::: {.cell-output-display}\n\n\n|metric          |  No|  Yes|\n|:---------------|---:|----:|\n|product_value   | 2.9| 3.75|\n|service_quality | 3.1| 3.79|\n\n\n:::\n:::\n\n\nAnd now compute the relative change:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstep4 <- step3 |>\n  mutate(\n    absolute_change = Yes - No,\n    relative_change = (absolute_change / No)*100\n    ) |>\n  select(-No, -Yes)\nkable(step4)\n```\n\n::: {.cell-output-display}\n\n\n|metric          | absolute_change| relative_change|\n|:---------------|---------------:|---------------:|\n|product_value   |            0.85|        29.31034|\n|service_quality |            0.69|        22.25806|\n\n\n:::\n:::\n\n\nOr, all in one call:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsatisfaction_summary |>\n  mutate(\n    intervention = ifelse(test = quarter==\"q1\", yes = \"No\", no = \"Yes\")\n    ) |>\n  summarise(\n    avg_rating = mean(avg_rating), .by = c(\"intervention\", \"metric\")\n  ) |>\n  pivot_wider(names_from = intervention, values_from = avg_rating) |>\n  mutate(\n    absolute_change = Yes - No,\n    relative_change = (absolute_change / No)*100\n    ) |>\n  select(-No, -Yes) |> \n  kable()\n```\n\n::: {.cell-output-display}\n\n\n|metric          | absolute_change| relative_change|\n|:---------------|---------------:|---------------:|\n|product_value   |            0.85|        29.31034|\n|service_quality |            0.69|        22.25806|\n\n\n:::\n:::\n\n\n## Exercise 2: Pricing Strategy Analysis\n\nFor this exercise we need the following packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(kableExtra) # <- only for the presentation on the webpage\n```\n:::\n\n\nSince the csv file is in good shape we can just read it via `data.table::fread()`\nor, because it is already very clean, with `readr::read_csv()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Note: adjust to you project and best use here::here()\npricing_data <- read_csv(\n  file = \"pricing_experiment.csv\")\n```\n:::\n\n\nThis is how the current data looks like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(pricing_data) |>\n  kable()\n```\n\n::: {.cell-output-display}\n\n\n| product_id| trial_number|pricing_strategy | conversion_rate| avg_transaction_value|\n|----------:|------------:|:----------------|---------------:|---------------------:|\n|          1|            1|standard         |       0.2196469|              74.61481|\n|          1|            2|standard         |       0.1786139|              68.50374|\n|          1|            3|standard         |       0.1726851|              70.15176|\n|          1|            1|discount_10      |       0.2051315|              86.48867|\n|          1|            2|discount_10      |       0.2219469|              65.79471|\n|          1|            3|discount_10      |       0.1923106|              94.04643|\n\n\n:::\n:::\n\n\nTo compute mean conversion rates and transaction values across trials for \neach product and pricing strategy, we group the data for products and pricing\nstrategies:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproduct_averages <- pricing_data |>\n  group_by(product_id, pricing_strategy) |>\n  summarise(\n    conversion_rate = mean(conversion_rate), \n    transaction_value = mean(avg_transaction_value), \n    .groups = \"drop\"\n    )\n\nhead(product_averages) |>\n  kable()\n```\n\n::: {.cell-output-display}\n\n\n| product_id|pricing_strategy | conversion_rate| transaction_value|\n|----------:|:----------------|---------------:|-----------------:|\n|          1|discount_10      |       0.2064630|          82.10994|\n|          1|premium          |       0.2215509|          85.57820|\n|          1|standard         |       0.1903153|          71.09011|\n|          2|discount_10      |       0.1798765|          87.74333|\n|          2|premium          |       0.1865313|          83.22130|\n|          2|standard         |       0.1988115|          86.61588|\n\n\n:::\n:::\n\n\nThe next task asks us to transform the data so that each row is one product and\nthe pricing strategies become separate columns for both \n`conversion_rate` and `avg_transaction_value`, but with column names \ncombining the information on the metric and pricing strategy.\n\nThat means we need to make the data wider, and use the argument `names_sep`\nto introduce a separator into the new column names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproduct_wide <- product_averages |>\n  pivot_wider(\n    id_cols = product_id,\n    names_from = pricing_strategy,\n    values_from = c(conversion_rate, transaction_value),\n    names_sep = \"_\"\n  )\n\nhead(product_wide) |>\n  kable()\n```\n\n::: {.cell-output-display}\n\n\n| product_id| conversion_rate_discount_10| conversion_rate_premium| conversion_rate_standard| transaction_value_discount_10| transaction_value_premium| transaction_value_standard|\n|----------:|---------------------------:|-----------------------:|------------------------:|-----------------------------:|-------------------------:|--------------------------:|\n|          1|                   0.2064630|               0.2215509|                0.1903153|                      82.10994|                  85.57820|                   71.09011|\n|          2|                   0.1798765|               0.1865313|                0.1988115|                      87.74333|                  83.22130|                   86.61588|\n|          3|                   0.2228304|               0.1969064|                0.2065927|                      71.98334|                  93.06214|                   87.98963|\n|          4|                   0.1818890|               0.1910592|                0.1884318|                      87.94258|                  96.17300|                   80.88020|\n|          5|                   0.1913803|               0.2032807|                0.2254633|                      87.26717|                  86.70312|                   86.14059|\n|          6|                   0.1917669|               0.2158156|                0.2073016|                      82.09762|                  73.18594|                   82.89268|\n\n\n:::\n:::\n\n\n\nWe now need to compute expected revenue per customer by multiplying\nconversion rates and average transaction values for each pricing strategy:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpected_revs <- product_wide |>\n  mutate(\n    standard_revenue = conversion_rate_standard * transaction_value_standard,\n    discount_10_revenue = conversion_rate_discount_10 * transaction_value_discount_10,\n    premium_revenue = conversion_rate_premium * transaction_value_premium\n  )\n\nhead(expected_revs) |>\n  kable()\n```\n\n::: {.cell-output-display}\n\n\n| product_id| conversion_rate_discount_10| conversion_rate_premium| conversion_rate_standard| transaction_value_discount_10| transaction_value_premium| transaction_value_standard| standard_revenue| discount_10_revenue| premium_revenue|\n|----------:|---------------------------:|-----------------------:|------------------------:|-----------------------------:|-------------------------:|--------------------------:|----------------:|-------------------:|---------------:|\n|          1|                   0.2064630|               0.2215509|                0.1903153|                      82.10994|                  85.57820|                   71.09011|         13.52954|            16.95266|        18.95992|\n|          2|                   0.1798765|               0.1865313|                0.1988115|                      87.74333|                  83.22130|                   86.61588|         17.22023|            15.78296|        15.52338|\n|          3|                   0.2228304|               0.1969064|                0.2065927|                      71.98334|                  93.06214|                   87.98963|         18.17801|            16.04007|        18.32453|\n|          4|                   0.1818890|               0.1910592|                0.1884318|                      87.94258|                  96.17300|                   80.88020|         15.24040|            15.99579|        18.37474|\n|          5|                   0.1913803|               0.2032807|                0.2254633|                      87.26717|                  86.70312|                   86.14059|         19.42155|            16.70121|        17.62507|\n|          6|                   0.1917669|               0.2158156|                0.2073016|                      82.09762|                  73.18594|                   82.89268|         17.18379|            15.74361|        15.79467|\n\n\n:::\n:::\n\n\nThis tells you the expected revenue from each pricing approach.\n\nFinally, we want a scatter plot that compares the pricing strategies for\neach product, illustrating whether the same pricing strategy is the best\nfor each product. To this end we create the scatter plot with expected\nrevenues for standard and discount pricing on the x and y axis, and add a\ndiagonal reference line. If all points are above (below) the reference line,\ndiscount (standard) pricing is always better:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data = expected_revs, \n  mapping = aes(\n    x = standard_revenue, \n    y = discount_10_revenue)\n  ) +\n  geom_abline(\n    intercept = 0, slope = 1, linetype = \"dashed\", \n    color = \"gray50\", linewidth = 1\n    ) +\n  geom_point(size = 3, alpha = 0.6, color = \"#0072B2\") +\n  labs(\n    title = \"Comparing Expected Revenue: \\nStandard vs. Discount Pricing\",\n    subtitle = \"Each point represents one product\",\n    x = \"Expected Revenue - Standard Pricing\",\n    y = \"Expected Revenue - 10% Discount Pricing\",\n    caption = \"Dashed line shows equal performance.\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\", size = 14),\n    plot.subtitle = element_text(size = 11, color = \"gray30\")\n  ) +\n  coord_fixed(ratio = 1)  # Makes comparison easier\n```\n\n::: {.cell-output-display}\n![](solution_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n",
    "supporting": [
      "solution_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}