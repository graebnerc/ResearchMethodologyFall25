{
  "hash": "9029ba1490362bf81840c64cdd35e95e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Recap exercises: import, preparation and visualization\"\ndate: \"2025-11-07\"\n---\n\nThe following exercises are meant to help you recap what you learned in the areas of \n*data import*, *data preparation* and *visualization*.\n\n- [Data for exercise 2](/content/material/Recap8b/pricing_experiment.csv)\n- [Template Exercise 1](/content/material/Recap8b/r_recap_exercise1.R)\n- [Template Exercise 2](/content/material/Recap8b/r_recap_exercise2.R)\n\n## Customer Satisfaction Tracking\n\n- [Data for exercise 1](/content/material/Recap8b/customer_satisfaction.csv)\n\n> **Background:**\nYou work for a company that recently implemented new customer service protocols.\nCustomer satisfaction data was collected at three time points: before the change (Q1),\nand at two follow-up periods (Q2, Q3). Customers rated their satisfaction with\nservice quality and product value on a 1-5 scale.\nEach row represents one customer's ratings across all three quarters.\n\n### Import data\n\nDownload the file `customer_satisfaction.csv`and place it in your working directory.\nImport the CSV file and store it in a variable called `customers_data`.\n\n### Prepare data\n\n\nThe data is currently in a *wide* format - each quarter is a separate column.\nTransform it to a tidy format where:\n- One column indicates the quarter (`q1`, `q2`, `q3`)\n- One column indicates the metric type (`service_quality`, `product_value`)\n- One column contains the rating value\n\n::: {.callout-tip collapse=\"true\"}\n#### Hint: how to separate columns\n:::\n\n### Compute grouped averages\n\nCalculate the mean rating for each combination of quarter and metric type.\nStore this in a new table called `satisfaction_summary`.\n\n## Visualization\n\nCreate a line plot showing how average customer satisfaction changes over \nquarters. It should have the quarters on the x-axis, the mean rating on the \ny-axis, and it should show different colors for service quality and product\nvalue.\n\n## Bonus: compute improvements\n\n# Solution\n\n\nFor this exercise we need the following packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(kableExtra) # <- only for the presentation on the webpage\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'kableExtra'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:dplyr':\n\n    group_rows\n```\n\n\n:::\n:::\n\n\nSince the csv file is in good shape we can just read it via `data.table::fread()`\nor, because it is already very clean, with `readr::read_csv()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Note: adjust to you project and best use here::here()\ncustomers_data <- read_csv(\n  file = \"Recap8b/customer_satisfaction.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 50 Columns: 8\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (8): customer_id, account_age_months, q1_service_quality, q1_product_val...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\nThis is how the current data looks like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(customers_data) |>\n  kable()\n```\n\n::: {.cell-output-display}\n\n\n| customer_id| account_age_months| q1_service_quality| q1_product_value| q2_service_quality| q2_product_value| q3_service_quality| q3_product_value|\n|-----------:|------------------:|------------------:|----------------:|------------------:|----------------:|------------------:|----------------:|\n|           1|                 12|                  3|                5|                  4|                2|                  5|                3|\n|           2|                 25|                  4|                1|                  4|                4|                  5|                3|\n|           3|                 34|                  4|                5|                  2|                3|                  5|                5|\n|           4|                 20|                  1|                5|                  5|                5|                  3|                5|\n|           5|                 16|                  3|                1|                  2|                5|                  5|                5|\n|           6|                 13|                  5|                1|                  5|                4|                  4|                4|\n\n\n:::\n:::\n\n\nTo transform it into the desired long format we use `tidyr::pivot_longer()`.\nHere we can make our live easier by using the selection helper `dplyr::starts_with()`\nto capture all columns starting with `q`.\nBut a simple application only brings us that far:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncustomers_data |>\n  pivot_longer(\n    cols = all_of(starts_with(\"q\"))\n    ) |>\n  head() |>\n  kable()\n```\n\n::: {.cell-output-display}\n\n\n| customer_id| account_age_months|name               | value|\n|-----------:|------------------:|:------------------|-----:|\n|           1|                 12|q1_service_quality |     3|\n|           1|                 12|q1_product_value   |     5|\n|           1|                 12|q2_service_quality |     4|\n|           1|                 12|q2_product_value   |     2|\n|           1|                 12|q3_service_quality |     5|\n|           1|                 12|q3_product_value   |     3|\n\n\n:::\n:::\n\n\nThe column `name` still contains information about both the quarter and the metric.\nThere are a number of ways we can separate this column.\n\nOne way would be to use the argument `names_sep` of `pivot_longer()` and then\ngive two column names to `names_to`. This works in our case but note that it\ngives a warning that some parts of the column are dropped:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncustomers_long <- customers_data |>\n  pivot_longer(\n    cols = starts_with(\"q\"), \n    names_sep = \"_\", \n    names_to = c(\"quarter\", \"metric\")\n    ) \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Expected 2 pieces. Additional pieces discarded in 6 rows [1, 2, 3, 4,\n5, 6].\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(customers_long)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  customer_id account_age_months quarter metric  value\n        <dbl>              <dbl> <chr>   <chr>   <dbl>\n1           1                 12 q1      service     3\n2           1                 12 q1      product     5\n3           1                 12 q2      service     4\n4           1                 12 q2      product     2\n5           1                 12 q3      service     5\n6           1                 12 q3      product     3\n```\n\n\n:::\n:::\n\n\nThis is because we\nare telling the function to separate the column using the token `_`, but this\ntoken appears more than once (but we only provide two column names). In our case\nthis is save to ignore, but when you want to avoid it, you can use the function\n`dplyr::separate()`, which allows for more sophisticate separation procedures.\nIn our case, we can set `extra = \"merge\"`, which tells the function to only \nsplit on the first underscore and keep everything else together:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncustomers_long <- customers_data |>\n  pivot_longer(\n    cols = starts_with(\"q\"),\n    names_to = \"full_name\",\n    values_to = \"rating\"\n  ) |>\n  separate(\n    col = full_name, \n    into = c(\"quarter\", \"metric\"), \n    sep = \"_\", \n    extra = \"merge\")\n\nhead(customers_long) |>\n  kable()\n```\n\n::: {.cell-output-display}\n\n\n| customer_id| account_age_months|quarter |metric          | rating|\n|-----------:|------------------:|:-------|:---------------|------:|\n|           1|                 12|q1      |service_quality |      3|\n|           1|                 12|q1      |product_value   |      5|\n|           1|                 12|q2      |service_quality |      4|\n|           1|                 12|q2      |product_value   |      2|\n|           1|                 12|q3      |service_quality |      5|\n|           1|                 12|q3      |product_value   |      3|\n\n\n:::\n:::\n\n\nNext we need to compute average ratings for each combination of quarter and \nmetric type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsatisfaction_summary <- customers_long |>\n  group_by(quarter, metric) |>\n  summarise(avg_rating = mean(rating), .groups = \"drop\") \n\nkable(satisfaction_summary)\n```\n\n::: {.cell-output-display}\n\n\n|quarter |metric          | avg_rating|\n|:-------|:---------------|----------:|\n|q1      |product_value   |       2.90|\n|q1      |service_quality |       3.10|\n|q2      |product_value   |       3.52|\n|q2      |service_quality |       3.44|\n|q3      |product_value   |       3.98|\n|q3      |service_quality |       4.14|\n\n\n:::\n:::\n\n\n\n> Note: there are different ways of doing this. Instead of the more explicit\n`group_by()` you could have used `summarize(..., .by=c())`.\n\nThe final step is then to create the visualization using `ggplot2`.\nThe only thing to note is that we need to be explicit regarding the grouping\nand set \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data = satisfaction_summary, \n  mapping = aes(\n    x = quarter, \n    y = avg_rating, \n    colour = metric, \n    group = metric)\n  ) +\n  geom_point() +\n  geom_line() +\n  theme_light()\n```\n\n::: {.cell-output-display}\n![](session08b_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n::: {.callout-tip collapse=\"true\"}\n#### Why do we need `group = metric`?\n\nWhen you use `geom_line()`, `ggplot2` needs to know which points to connect. \nBy default, `ggplot2` automatically creates groups based on the combination of \nall discrete variables in your data.\nIn our case these are the two variables `quarter` and `metric`.\n\nSo `ggplot2` creates groups based on the combination of both these variables:\n\n1. `q1 + product_value` (1 point)\n2. `q1 + service_quality` (1 point)\n3. `q2 + product_value` (1 point)\n4. `q2 + service_quality` (1 point)\n5. `q3 + product_value` (1 point)\n6. `q3 + service_quality` (1 point)\n\nEach group has only one observation, so there's nothing to connect with a line!\n\nWhat we *actually* want is to have separate lines for each metric, i.e.\none line for `product_value` across all quarters and \none line for `service_quality` across all quarters. \n\nSo you need to tell `ggplot2`: \n\"Group by metric only, not by the combination of all discrete variables, \nwhich would be quarter and metric!\"\n\n:::\n\n\nOf course, there are many ways to make the plot pretties, but here we may leave\nit at this!\n\nTo also complete the bonus challenge, we need to compute the improvement after\nthe intervention, i.e. from `q1` to the other two quarters. We will do this by\ncomputer the average for `q2` and `q3`, compute the relative change to `q1` and\nthen rank the data according to their relative changes.\n\nHere are all steps conducted separately: first, create a new variable to\ngroup periods before and after the intervention:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstep1 <- satisfaction_summary |>\n  mutate(\n    intervention = ifelse(test = quarter==\"q1\", yes = \"No\", no = \"Yes\")\n    )\nkable(step1)\n```\n\n::: {.cell-output-display}\n\n\n|quarter |metric          | avg_rating|intervention |\n|:-------|:---------------|----------:|:------------|\n|q1      |product_value   |       2.90|No           |\n|q1      |service_quality |       3.10|No           |\n|q2      |product_value   |       3.52|Yes          |\n|q2      |service_quality |       3.44|Yes          |\n|q3      |product_value   |       3.98|Yes          |\n|q3      |service_quality |       4.14|Yes          |\n\n\n:::\n:::\n\n\n\nNow compute the respective averages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstep2 <- step1 |>\n  summarise(\n    avg_rating = mean(avg_rating), .by = c(\"intervention\", \"metric\")\n    )\nkable(step2)\n```\n\n::: {.cell-output-display}\n\n\n|intervention |metric          | avg_rating|\n|:------------|:---------------|----------:|\n|No           |product_value   |       2.90|\n|No           |service_quality |       3.10|\n|Yes          |product_value   |       3.75|\n|Yes          |service_quality |       3.79|\n\n\n:::\n:::\n\n\nMake it wider:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstep3 <- step2 |>\n  pivot_wider(names_from = intervention, values_from = avg_rating) \nkable(step3)\n```\n\n::: {.cell-output-display}\n\n\n|metric          |  No|  Yes|\n|:---------------|---:|----:|\n|product_value   | 2.9| 3.75|\n|service_quality | 3.1| 3.79|\n\n\n:::\n:::\n\n\nAnd now compute the relative change:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstep4 <- step3 |>\n  mutate(\n    absolute_change = Yes - No,\n    relative_change = (absolute_change / No)*100\n    ) |>\n  select(-No, -Yes)\nkable(step4)\n```\n\n::: {.cell-output-display}\n\n\n|metric          | absolute_change| relative_change|\n|:---------------|---------------:|---------------:|\n|product_value   |            0.85|        29.31034|\n|service_quality |            0.69|        22.25806|\n\n\n:::\n:::\n\n\nOr, all in one call:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsatisfaction_summary |>\n  mutate(\n    intervention = ifelse(test = quarter==\"q1\", yes = \"No\", no = \"Yes\")\n    ) |>\n  summarise(\n    avg_rating = mean(avg_rating), .by = c(\"intervention\", \"metric\")\n  ) |>\n  pivot_wider(names_from = intervention, values_from = avg_rating) |>\n  mutate(\n    absolute_change = Yes - No,\n    relative_change = (absolute_change / No)*100\n    ) |>\n  select(-No, -Yes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 3\n  metric          absolute_change relative_change\n  <chr>                     <dbl>           <dbl>\n1 product_value              0.85            29.3\n2 service_quality            0.69            22.3\n```\n\n\n:::\n:::\n\n",
    "supporting": [
      "session08b_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}